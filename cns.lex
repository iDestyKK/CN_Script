/*
 * Lex grammar for CN_Script.
 *
 * Description:
 *     CN_Script is a subset of the C language which integrates tools that make
 *     coding in C a bit more managable, including data structures and other
 *     tools to enforce good coding behaviour. The CN_Script language will
 *     "transpile" into valid C Code (assuming you didn't mess up at all), and
 *     can be compiled with a C compiler afterwards.
 *
 * Author:
 *     Clara Nguyen
 */

%{
	/* C Includes */
	#include <stdio.h>
	#include <stdlib.h>
	#include <errno.h>

	/* Generated by yacc */
	#include "cns.tab.h"

	/* Globals */
	int inline_c_bracket_counter;
%}

%option noyywrap nounput yylineno
%x      INLINE_C COMMENT FUNC_DECL

ascii          [a-zA-Z_]
ascii_num      [a-zA-Z0-9_]
fname          [a-zA-Z0-9_\.\/\\]
ptr            [\*]
array          [\[\]]

name           {ascii}{ascii_num}*
type           {ptr}*{name}{ptr}*(\[\])*
templated_type {ptr}*^"func"\<{name}(\,{name})*\>{ptr}*(\[\])*
double_t       [0-9]+\.[0-9]+
int_t          [0-9]+

%%
 /* Lex Grammar */

 /* 
  * ---------------------------------------------------------------------------
  * CN_SCRIPT LANGUAGE SYNTAX
  * ---------------------------------------------------------------------------
  */

"#import" {
	/* CN_Script Import */
	yylval.str = "import";
	return IMPORT;
}

"#cimport" {
	/* C Import */
	yylval.str = "include";
	return IMPORT;
}

"/*" {
	/* Multi-line comment */
	printf("%s", yytext);
	BEGIN COMMENT;
}

<COMMENT>"*/" {
	printf("%s", yytext);
	BEGIN 0;
}

<COMMENT>. {
	printf("%s", yytext);
}

"//".*"\n" {
	/* Single-line comment */
	printf("%s", yytext);
}

"func"   { return FUNC; }
"fend"   { return FEND; }
"object" { return OBJECT; }

 /*
  * ---------------------------------------------------------------------------
  * CN_SCRIPT LOOPS & CONDITIONALS
  * ---------------------------------------------------------------------------
  */
"if"      { return IF; }      /* For "If" statements                      */
"else"    { return ELSE; }    /* If an "if" condition fails, execute this */
"for"     { return FOR; }     /* For "For" loops                          */
"do"      { return DO; }      /* For "Do-While" and "Do-Until" loops      */
"while"   { return WHILE; }   /* For "While" and "Do-While" loops         */
"until"   { return UNTIL; }   /* For "Do-Until" loops                     */
"repeat"  { return REPEAT; }  /* Repeat X number of times                 */
"loop"    { return LOOP;    } /* Loop forever until broken                */

 /*
  * ---------------------------------------------------------------------------
  * CN_SCRIPT OPERATORS
  * ---------------------------------------------------------------------------
  */

"=="         { return EQ; }
"+="         { return ADDEQ; }
"-="         { return SUBEQ; }
"*="         { return MULEQ; }
"/="         { return DIVEQ; }
"%="         { return MODEQ; }
"<<="        { return LSEQ; }
">>="        { return RSEQ; }
"&="         { return ANDEQ; }
"|="         { return OREQ; }
"^="         { return XOREQ; }
"!="         { return NOTEQ; }
"<="         { return LEQ; }
">="         { return GEQ; }

("&&"|"and") { return AND; }
("||"|"or")  { return OR; }
("^^"|"xor") { return XOR; }

"("  |
")"  |
"{"  |
"}"  |
"<"  |
">"  |
":"  |
","  |
"\"" |
"="  |
"+"  |
"-"  |
"*"  |
"/"  |
"%"  |
"|"  |
"&"  |
"^"  |
"!"  |
";"  { return yytext[0]; }

{int_t} { 
	yylval.str = strdup(yytext);
	return INT; 
}
{double_t} {
	yylval.str = strdup(yytext);
	return DOUBLE;
}

"\"".*"\"" {
	yylval.str = strdup(yytext);
	return STRING_LITERAL;
}

{fname}+ |
{type}   |
{templated_type}   |
{name}   {
	/*
	 * Type Array Bracket Declaration
	 */
	yylval.str = strdup(yytext);
	return NAME;
}

 /*
  * ---------------------------------------------------------------------------
  * INLINE RAW C CODE
  *
  * CN_Script allows inlining of C code. This code must be perfectly valid
  * C code that follows whatever standard you are compiling to.
  * ---------------------------------------------------------------------------
  */

"__INLINE_C {" {
	/*
	 * Begin Inlining
	 */
	
	BEGIN INLINE_C;
	inline_c_bracket_counter = 0;
}

<INLINE_C>"{" {
	printf("{");
	inline_c_bracket_counter++;
}

<INLINE_C>"}" {
	if (inline_c_bracket_counter) {
		printf("}");
		inline_c_bracket_counter--;
	}
	else
		BEGIN 0;
}

<INLINE_C>. {
	printf("%s", yytext);
}

 /* 
  * ---------------------------------------------------------------------------
  * FUNCTIONS
  * ---------------------------------------------------------------------------
  */
[\r\n]+ {
	printf("%s", yytext);
}

[\t]+ {
	printf("%s", yytext);
}

. {
	//return yytext[0];
}
